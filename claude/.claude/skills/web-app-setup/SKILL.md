---
name: web-app-setup
description: |
  Web アプリをゼロから立ち上げるための一気通貫ワークフロー。技術スタックが未決定の状態から、ビジネス要件ヒアリング → アーキテクチャ設計 → 技術スタックの網羅的な選定 → ディレクトリ設計 → Git・ブランチ戦略 → AI エージェント並行開発体制の構築 → 環境セットアップ → ローカルでの動作確認までを実行する。
  このスキルは、ユーザーがまだ技術選定を行っておらず、アーキテクチャ設計から環境構築までを一括で進めたい場合に使用する。「新しい Web アプリを作りたいけど何も決まっていない」「技術選定の自由度が高いのでベストな構成を一緒に考えたい」「プロジェクトがゼロの状態なので設計から環境構築までフルでお願いしたい」「技術に詳しくないから全部おまかせしたい」といったリクエストに対応する。SaaS、EC サイト、社内ツール、IoT ダッシュボード、ハッカソンプロジェクト等、Web アプリ全般に対応。
  ただし、以下のケースではこのスキルを使わないこと：使用フレームワークが既に決まっている場合（例：「Next.js で○○を作りたい」）、既存プロジェクトへの機能追加、バグ修正やパフォーマンス改善、インフラ構築のみ、モバイルアプリ開発。
---

# Web App Setup ワークフロー

## 基本原則

- **役割分担**: AI が調査・比較分析・推奨の提示・実行・検証を行い、ユーザーがレビュー・判断・決定する
- **プリセット禁止**: 技術的な決定を暗黙的に行わない。パッケージ化された構成の提案はしない。すべての技術要素を1項目ずつユーザーと議論し、個別に決定する
- **ユーザープロファイル反映**: ユーザーの技術的背景（得意分野、経験、学習コスト許容度）を比較分析の判断軸に含める
- **全体最適の担保**: 個別決定した技術群の整合性を全決定完了後に評価し、矛盾・非効率があれば指摘する

## コンテキスト管理: Decision State Document

各フェーズのユーザー承認後、決定事項を `setup-decisions.md`（プロジェクトルート）に追記する。Phase 4 のサブエージェントにはこのファイルのパスを渡し、会話履歴なしで作業できるようにする。

## ワークフロー全体像

```
Phase 1: ビジネス要件・ユーザープロファイルのヒアリング
    ↓ [ユーザー承認] → setup-decisions.md 作成
Phase 2: アーキテクチャ設計
    ↓ [ユーザー承認] → setup-decisions.md 追記
Phase 3: 技術決定項目の棚卸し
    ↓ [ユーザー承認] → setup-decisions.md 追記
Phase 4: 技術選定（サブエージェント並列リサーチ → ユーザー決定）
  Phase 4.5: 技術スタック全体の整合性評価
    ↓ [ユーザー承認] → setup-decisions.md 確定
Phase 5: ディレクトリ構造設計
    ↓ [ユーザー承認] → setup-decisions.md 追記
Phase 6: Git・ブランチ戦略
    ↓ [ユーザー承認] → setup-decisions.md 追記
Phase 7: AI 並行開発体制の設計
    ↓ [ユーザー承認] → setup-decisions.md 追記
Phase 8: 環境構築の実行
    ↓
Phase 9: 動作確認（自動検証を含む）
    ↓ [ユーザー承認]
完了
```

各フェーズの末尾にチェックポイントがある。ユーザーの承認を得てから次フェーズに進む。

---

## Phase 1: ビジネス要件・ユーザープロファイルのヒアリング

会話の中で既に判明している情報は改めて聞かなくてよい。

- **ビジネス要件**: アプリ概要、ターゲットユーザー・規模、MVP 機能、非機能要件、制約条件、デプロイ先
- **ユーザープロファイル**: 技術的バックグラウンド（得意言語・FW）、チーム構成、学習コストへの姿勢、重視する価値観（生産性 / 型安全性 / シンプルさ / コントロール性）

**承認後**: `setup-decisions.md` を作成し、ビジネス要件とユーザープロファイルを記載する。

---

## Phase 2: アーキテクチャ設計

ビジネス要件に基づき、以下の各観点について選択肢を調査・比較し、1つずつユーザーが決定する。

- アプリケーション形態（SPA / SSR / SSG / ハイブリッド等）
- レンダリング戦略
- 構成パターン（モノリス / API 境界分離 / BFF）
- API 設計アプローチ（REST / GraphQL / tRPC 等）
- API 契約・ドキュメンテーション
- モジュール設計方針（Clean Architecture / DDD / 機能ベース等）
- データストア（RDB / NoSQL 等）
- リアルタイム通信（必要な場合）

**承認後**: アーキテクチャをテーブル形式で `setup-decisions.md` に追記する。

---

## Phase 3: 技術決定項目の棚卸し

アーキテクチャに基づき、決定が必要な技術要素を**網羅的に**洗い出す。以下はベースラインのチェックリスト。プロジェクト特性に応じて追加・除外する。

**言語・フレームワーク**: プログラミング言語 / フロントエンド FW / バックエンド FW / メタフレームワーク

**データ・インフラ**: DB 製品 / ORM・クエリビルダー / キャッシュ戦略 / コンテナ化 / デプロイプラットフォーム

**フロントエンド固有**:
- CSS・スタイリング手法
- デザインシステム・UI ライブラリ
- ルーティング戦略
- データフェッチ・クライアントキャッシュ
- 状態管理
- フォームバリデーション

**開発ツールチェーン**: パッケージマネージャー / モノレポツール / リンター・フォーマッター / テスト FW（単体・統合・E2E） / CI/CD

**アプリケーション横断**: 認証・認可 / エラートラッキング・ロギング / 環境変数管理 / API ドキュメンテーションツール

各項目には**依存関係**を明記する（例: 「ルーティング → フロントエンドFWに依存」）。この依存情報は Phase 4 の並列リサーチに使う。

項目リストをユーザーと合意してから Phase 4 に進む。

**承認後**: 技術決定項目（依存関係付き）を `setup-decisions.md` に追記する。

---

## Phase 4: 技術選定

### 依存関係によるレイヤー分け

Phase 3 のチェックリストを依存関係に基づきレイヤーに分ける。上位レイヤーから順に選定する。

```
レイヤー1（依存なし）: 言語、パッケージマネージャー 等
    ↓
レイヤー2（レイヤー1に依存）: フロントエンドFW、バックエンドFW 等
    ↓
レイヤー3（レイヤー2に依存）: ルーティング、ORM、状態管理 等
    ↓
レイヤー4（レイヤー3に依存）: UIライブラリ、テストFW 等
```

同一レイヤー内の項目は互いに独立しているため、**並列リサーチが可能**。

### リサーチの実行（サブエージェントに委任）

各レイヤーについて、含まれる項目の数だけ Agent ツール（`subagent_type: "general-purpose"`）でサブエージェントを**同時に**起動する。[references/tech-research-prompt.md](references/tech-research-prompt.md) を Read してプロンプトテンプレートを取得し、各項目の値を埋めて渡す。

同一レイヤーの全サブエージェントを1つの応答内で並列呼び出しする。レイヤー間は順次実行（前レイヤーの決定が `setup-decisions.md` に反映されてから次レイヤーを開始）。

サブエージェントの返却結果（比較表 + 推奨）をそのままユーザーに提示し、ユーザーが決定したら `setup-decisions.md` の技術選定ログを更新する。

### Phase 4.5: 技術スタック全体の整合性評価

全項目の選定完了後、決定ログ一覧を提示し、技術間の相性・互換性・重複・不足・全体複雑度を評価する。問題があれば代替案を提示する。

**承認後**: 技術選定ログを確定し `setup-decisions.md` を更新する。

---

## Phase 5: ディレクトリ構造設計

Phase 2 のモジュール設計方針と Phase 4 の技術選定に基づき、ディレクトリ構造を設計する。ディレクトリツリーと各ディレクトリの役割を提示し、ユーザーと議論して決定する。

**承認後**: ディレクトリ構造を `setup-decisions.md` に追記する。

---

## Phase 6: Git・ブランチ戦略

以下の項目について選択肢を提示し、ユーザーが決定する：ブランチ戦略 / 命名規則 / コミットメッセージ規約 / 保護ルール / マージ戦略 / レビュー方針

**承認後**: Git 戦略を `setup-decisions.md` に追記する。

---

## Phase 7: AI 並行開発体制の設計

複数 AI エージェントが同時に開発しても破綻しない仕組みを設計する。

- **ワークスペース分離**: Git worktree の活用ルール
- **モジュール境界と担当分離**: エージェント間のファイル競合を最小化する担当領域
- **ロックファイル戦略**: パッケージ追加時の競合防止ルール
- **CLAUDE.md 方針**: プロジェクト規約として記載する内容の設計（アーキテクチャ概要、決定ログ、コーディング規約、AI 向け作業ルール）

**承認後**: AI 開発体制を `setup-decisions.md` に追記する。

---

## Phase 8: 環境構築の実行

`setup-decisions.md` の全決定内容に基づき、**実際にコマンドを実行して**環境を構築する。計画を書くのではなく動く環境を作る。

プロジェクト scaffolding → Git 初期化 → 依存インストール → ディレクトリ整備 → リンター・フォーマッター設定 → テスト環境セットアップ → DB セットアップ（シードデータ投入まで） → `.env` 設定（`.env.example` + ローカル用デフォルト値） → Docker 設定 → CLAUDE.md 作成 → 初期コミット

---

## Phase 9: 動作確認（自動検証を含む）

環境構築の完了を**実際にコマンドを実行して**検証する。依存パッケージ、開発サーバー起動、リンター、テスト実行、DB 接続、Git コミット、CLAUDE.md を確認する。

開発サーバー起動後は **Playwright CLI 等の E2E ツール**でページ表示を自動検証する（ヘッドレスブラウザで HTTP 200 とページ要素の存在を確認）。未導入の場合は `curl` で代替する。
